// Copyright 2019-2021, Reinhard Feger,
// Institute for Communications Engineering and RF-Systems,
// Johannes Kepler University Linz, Austria and all contributors
// SPDX-License-Identifier: MIT

/* Driver for internal DAC */

#include "internal_dac.h"
#include "stm32h7xx_hal.h"
#include "memory.h"
#include "errno.h"

#include "main.h" //for LED definitions

// the dma-buffer has to be placed in the correct memory region
#define DMA_BUFFER \
    __attribute__((section(".dma_buffer"))) __attribute__ ((aligned (4)))
DMA_BUFFER uint32_t int_dac1_dma_buffer[INT_DAC_MAX_BUFFER_LENGTH]; //do not use this from the outside
// DMA_BUFFER uint16_t int_dac2_dma_buffer[INT_DAC_BUFFER_LENGTH];

int8_t int_dac_set_nsamp(struct int_dac_dev_s *self, uint16_t nsamp);
int8_t int_dac_set_sample(struct int_dac_dev_s *self, uint16_t val, uint16_t idx);
int8_t int_dac_fill_buf(struct int_dac_dev_s *self, uint16_t *data);
int8_t int_dac_arm(struct int_dac_dev_s *self);

void int_dac_dev_init(struct int_dac_dev_s *self, struct tim_dev_s *tim_dev, DAC_HandleTypeDef *hdac)
{
    self->hdac = hdac;
    self->set_nsamp = &int_dac_set_nsamp;
    self->set_sample = &int_dac_set_sample;
    self->fill_buf = &int_dac_fill_buf;
    self->arm = &int_dac_arm;
    self->nsamp = INT_DAC_MAX_BUFFER_LENGTH;
}

int8_t int_dac_set_nsamp(struct int_dac_dev_s *self, uint16_t nsamp)
{
    if(nsamp <= INT_DAC_MAX_BUFFER_LENGTH)
    {
        self->nsamp = nsamp;
        errno = 0;
        return 0;
    }
    else
    {
        errno = EOVERFLOW;
        return -1;
    }
}

int8_t int_dac_set_sample(struct int_dac_dev_s *self, uint16_t val, uint16_t idx)
{
    if(idx < self->nsamp)
    {
        int_dac1_dma_buffer[idx]=val;
        errno = 0;
        return 0;
    }
    else
    {        
        errno = EOVERFLOW;
        return 0;
    }
}

int8_t int_dac_fill_buf(struct int_dac_dev_s *self, uint16_t *data)
{     
    memcpy(int_dac1_dma_buffer, data, INT_DAC_MAX_BUFFER_LENGTH*sizeof(int_dac1_dma_buffer[0]));
    //TODO: check for errors
    errno = 0;
    return 0;
}

int8_t int_dac_arm(struct int_dac_dev_s *self)
{
    if(self->nsamp > INT_DAC_MAX_BUFFER_LENGTH)
    {        
        errno = EOVERFLOW;
        return 0;
    }
    // conversion clock is generated by timer, arming does not output samples until the timer is started
    // make sure that dma-buffer is in the correct memory region
    if(HAL_DAC_Start_DMA(self->hdac, DAC_CHANNEL_1, int_dac1_dma_buffer, self->nsamp, DAC_ALIGN_12B_R) != HAL_OK)
    {
        /* Start Error */
        Error_Handler();
    }
    // if(HAL_DAC_Start_DMA(self->hdac, DAC_CHANNEL_2, int_dac2_dma_buffer, self->nsamp, DAC_ALIGN_12B_R) != HAL_OK)
    // {
    //     /* Start Error */
    //     Error_Handler();
    // }
    //TODO: check for other errors
    errno = 0;
    return 0;
}
